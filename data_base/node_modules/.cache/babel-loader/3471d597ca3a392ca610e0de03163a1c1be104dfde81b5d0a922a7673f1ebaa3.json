{"ast":null,"code":"var _jsxFileName = \"/Users/hiyu/data_base/data_base/src/component/MapComp.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { MapContainer, TileLayer, Popup, Circle } from \"react-leaflet\";\nimport { Slider, Typography } from '@mui/material';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function MapMarker() {\n  _s();\n  const [year, SetYear] = useState(2000);\n  const [updatedData, SetUpdatedData] = useState(null);\n  const mapRef = useRef(null);\n  const markersRef = useRef([]);\n\n  // WikiDataのSPARQLエンドポイント、LeafletマップのベースURLと設定\n  const endpoint = \"/api/population-data/\";\n  const baseUrl = \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\";\n  const baseAttribution = 'Map data &copy; OpenStreetMap contributors, Tiles Courtesy of OpenStreetMap Japan';\n  const opacity = 0.6;\n  const maxZoom = 5;\n\n  //* dataのフェッチ\n  const fetchData = async () => {\n    const response = await fetch(endpoint);\n    const data = await response.json();\n  };\n\n  //* データの前処理(年ごとのデータが複数ある想定のクエリ（人口など))\n  const preprocessData = data => {\n    //* 国ごとの情報にした連想配列へ変換\n    let result = {};\n    data.results.bindings.forEach(element => {\n      let lat = parseFloat(element.lat.value);\n      let long = parseFloat(element.long.value);\n      let country = element.countryLabel.value;\n      let population = parseInt(element.population.value);\n      let time = parseInt(element.year.value);\n      if (!result[country]) {\n        result[country] = {\n          position: [lat, long],\n          population: [population],\n          time: [time],\n          radius: [Math.sqrt(population) / 1000]\n        };\n      } else {\n        result[country].population.push(population);\n        result[country].time.push(time);\n      }\n    });\n    //* 補間\n    Object.keys(result).forEach(countryKey => {\n      let populationArray = result[countryKey].population;\n      let timeArray = result[countryKey].time;\n      let radiusArray = result[countryKey].radius;\n      for (let i = 0; i < timeArray.length - 1; i++) {\n        let curTime = timeArray[i];\n        let nxTime = timeArray[i + 1];\n        let interval = nxTime - curTime;\n        if (interval > 1) {\n          let difPopulation = populationArray[i + 1] - populationArray[i];\n          let difAvg = difPopulation / interval;\n          for (let j = 1; j < interval; j++) {\n            let interpolatedPopulation = populationArray[i] + difAvg * j;\n            populationArray.splice(i + j, 0, interpolatedPopulation);\n            timeArray.splice(i + j, 0, curTime + j);\n            radiusArray.splice(i + j, 0, Math.sqrt(interpolatedPopulation) / 1000);\n          }\n          i += interval;\n        } else {\n          populationArray.splice(i, 0, populationArray[i]);\n          timeArray.splice(i, 0, curTime);\n          radiusArray.splice(i, 0, Math.sqrt(populationArray[i]) / 1000);\n        }\n      }\n      result[countryKey].population = populationArray;\n      result[countryKey].time = timeArray;\n      result[countryKey].radius = radiusArray;\n    });\n    return result;\n  };\n  const getData = (data, year) => {\n    //* 年ごとのデータを取得\n    let result = {};\n    Object.keys(data).forEach(countryKey => {\n      let countryData = data[countryKey];\n      let yearIndex = countryData.time.indexOf(year);\n      if (yearIndex !== -1) {\n        result[countryKey] = {\n          lat: countryData.position[0],\n          long: countryData.position[1],\n          yearPopulation: countryData.population[yearIndex],\n          yearRadius: countryData.radius[yearIndex]\n        };\n      } else {\n        return;\n      }\n    });\n    return result;\n  };\n  useEffect(() => {\n    const prepareData = async () => {\n      const fetch = await fetchData(endpoint, query);\n      const data = await preprocessData(fetch);\n      SetUpdatedData(data);\n    };\n    prepareData();\n  }, []);\n  useEffect(() => {\n    // 地図の初期設定（初回のみ実行）\n    if (!mapRef.current) {\n      mapRef.current = L.map('map').setView([20, 0], 2);\n      L.tileLayer(baseUrl, {\n        attribution: baseAttribution,\n        maxZoom\n      }).addTo(mapRef.current);\n    }\n    const updateMarkers = async () => {\n      // const fetch = await fetchData(endpoint, query);\n      // const data = await preprocessData(fetch);\n      const data = updatedData;\n      const yearData = await getData(data, year);\n\n      //* 既存のマーカーを削除\n      markersRef.current.forEach(marker => mapRef.current.removeLayer(marker));\n      markersRef.current = [];\n\n      //* 新しいデータでマーカーを更新\n      Object.keys(yearData).forEach(country => {\n        const countryData = yearData[country];\n        const lat = countryData.lat;\n        const long = countryData.long;\n        const population = countryData.yearPopulation;\n        const radius = countryData.yearRadius;\n        const marker = L.circleMarker([lat, long], {\n          radius,\n          color: \"#007bff\",\n          fillColor: \"#007bff\",\n          fillOpacity: opacity\n        }).bindPopup(`${country}<br>Population: ${population.toLocaleString()}`);\n        marker.addTo(mapRef.current);\n        markersRef.current.push(marker);\n      });\n    };\n    updateMarkers(); // 年が変更されるたびにマーカーを更新\n  }, [year]); // yearが変わるたびに再描画\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      id: \"map\",\n      style: {\n        height: \"90vh\"\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(Typography, {\n      variant: \"h6\",\n      align: \"center\",\n      children: year\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 158,\n      columnNumber: 19\n    }, this), /*#__PURE__*/_jsxDEV(Slider, {\n      value: year,\n      min: 2000,\n      max: 2020,\n      step: 1,\n      onChange: (event, newValue) => SetYear(newValue),\n      \"aria-labelledby\": \"year-slider\",\n      valueLabelDisplay: \"auto\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 13\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 156,\n    columnNumber: 11\n  }, this);\n}\n_s(MapMarker, \"ZExgO6gsDqTeNU9KeViTnAy73So=\");\n_c = MapMarker;\nvar _c;\n$RefreshReg$(_c, \"MapMarker\");","map":{"version":3,"names":["React","useEffect","useRef","useState","MapContainer","TileLayer","Popup","Circle","Slider","Typography","L","jsxDEV","_jsxDEV","MapMarker","_s","year","SetYear","updatedData","SetUpdatedData","mapRef","markersRef","endpoint","baseUrl","baseAttribution","opacity","maxZoom","fetchData","response","fetch","data","json","preprocessData","result","results","bindings","forEach","element","lat","parseFloat","value","long","country","countryLabel","population","parseInt","time","position","radius","Math","sqrt","push","Object","keys","countryKey","populationArray","timeArray","radiusArray","i","length","curTime","nxTime","interval","difPopulation","difAvg","j","interpolatedPopulation","splice","getData","countryData","yearIndex","indexOf","yearPopulation","yearRadius","prepareData","query","current","map","setView","tileLayer","attribution","addTo","updateMarkers","yearData","marker","removeLayer","circleMarker","color","fillColor","fillOpacity","bindPopup","toLocaleString","children","id","style","height","fileName","_jsxFileName","lineNumber","columnNumber","variant","align","min","max","step","onChange","event","newValue","valueLabelDisplay","_c","$RefreshReg$"],"sources":["/Users/hiyu/data_base/data_base/src/component/MapComp.js"],"sourcesContent":["import React, {useEffect, useRef, useState} from \"react\";\r\nimport {MapContainer, TileLayer, Popup, Circle} from \"react-leaflet\";\r\n\r\nimport {Slider, Typography} from '@mui/material';\r\nimport L from 'leaflet';\r\nimport 'leaflet/dist/leaflet.css';\r\n\r\nexport default function MapMarker() {\r\n    const [year, SetYear] = useState(2000);\r\n    const [updatedData, SetUpdatedData] = useState(null);\r\n    const mapRef = useRef(null);\r\n    const markersRef = useRef([]);\r\n    \r\n    // WikiDataのSPARQLエンドポイント、LeafletマップのベースURLと設定\r\n    const endpoint = \"/api/population-data/\";\r\n    const baseUrl = \"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\";\r\n    const baseAttribution = 'Map data &copy; OpenStreetMap contributors, Tiles Courtesy of OpenStreetMap Japan';\r\n    const opacity = 0.6;\r\n    const maxZoom = 5;\r\n    \r\n\r\n    //* dataのフェッチ\r\n    const fetchData = async () => {\r\n        const response = await fetch(endpoint);\r\n        const data = await response.json();\r\n    };\r\n\r\n    //* データの前処理(年ごとのデータが複数ある想定のクエリ（人口など))\r\n    const preprocessData = (data) => {\r\n        //* 国ごとの情報にした連想配列へ変換\r\n        let result = {};\r\n        data.results.bindings.forEach(element => {\r\n            let lat = parseFloat(element.lat.value);\r\n            let long = parseFloat(element.long.value);\r\n            let country = element.countryLabel.value;\r\n            let population = parseInt(element.population.value);\r\n            let time = parseInt(element.year.value);\r\n\r\n            if (!result[country]){\r\n                result[country] = {\r\n                    position: [lat, long],\r\n                    population: [population],\r\n                    time: [time],\r\n                    radius: [Math.sqrt(population) / 1000]\r\n                };\r\n            }\r\n            else {\r\n                result[country].population.push(population);\r\n                result[country].time.push(time);\r\n            }\r\n        })\r\n        //* 補間\r\n        Object.keys(result).forEach(countryKey => {\r\n            let populationArray = result[countryKey].population;\r\n            let timeArray = result[countryKey].time;\r\n            let radiusArray = result[countryKey].radius;\r\n\r\n            for (let i = 0; i < timeArray.length - 1; i++) {\r\n                let curTime = timeArray[i];\r\n                let nxTime = timeArray[i+1];\r\n                let interval = nxTime - curTime;\r\n                if (interval > 1) {\r\n                    let difPopulation = populationArray[i+1] - populationArray[i];\r\n                    let difAvg = difPopulation / interval;\r\n                    for (let j = 1; j < interval; j++) {\r\n                        let interpolatedPopulation = populationArray[i]+difAvg*j\r\n                        populationArray.splice(i+j, 0, interpolatedPopulation);\r\n                        timeArray.splice(i+j, 0, curTime+j);\r\n                        radiusArray.splice(i+j, 0, Math.sqrt(interpolatedPopulation) / 1000);\r\n                    }\r\n                    i += interval;\r\n                }\r\n                else {\r\n                    populationArray.splice(i, 0, populationArray[i]);\r\n                    timeArray.splice(i, 0, curTime);\r\n                    radiusArray.splice(i, 0, Math.sqrt(populationArray[i]) / 1000);\r\n                }\r\n            }\r\n            result[countryKey].population = populationArray;\r\n            result[countryKey].time = timeArray;\r\n            result[countryKey].radius = radiusArray;\r\n        })\r\n        return result\r\n    }\r\n\r\n    const getData = (data, year) => { //* 年ごとのデータを取得\r\n        let result = {};\r\n        Object.keys(data).forEach(countryKey => {\r\n            let countryData = data[countryKey];\r\n            let yearIndex = (countryData.time).indexOf(year);\r\n            if (yearIndex !== -1){\r\n                result[countryKey] = {\r\n                    lat: countryData.position[0],\r\n                    long: countryData.position[1],\r\n                    yearPopulation: countryData.population[yearIndex],\r\n                    yearRadius: countryData.radius[yearIndex]\r\n                }\r\n            }\r\n            else {\r\n                return ;\r\n            }\r\n            })\r\n        return result;\r\n    }\r\n\r\n    useEffect(() => {\r\n        const prepareData = async () => {\r\n            const fetch = await fetchData(endpoint, query);\r\n            const data = await preprocessData(fetch);\r\n            SetUpdatedData(data);\r\n        };\r\n        prepareData();\r\n    }, [])\r\n\r\n    useEffect(() => {\r\n        // 地図の初期設定（初回のみ実行）\r\n        if (!mapRef.current) {\r\n          mapRef.current = L.map('map').setView([20, 0], 2);\r\n          L.tileLayer(baseUrl, { attribution: baseAttribution, maxZoom }).addTo(mapRef.current);\r\n        }\r\n        \r\n        const updateMarkers = async () => {\r\n            // const fetch = await fetchData(endpoint, query);\r\n            // const data = await preprocessData(fetch);\r\n            const data = updatedData;\r\n            const yearData = await getData(data, year);\r\n\r\n            //* 既存のマーカーを削除\r\n            markersRef.current.forEach(marker => mapRef.current.removeLayer(marker));\r\n            markersRef.current = [];\r\n\r\n            //* 新しいデータでマーカーを更新\r\n            Object.keys(yearData).forEach(country => {\r\n                const countryData = yearData[country];\r\n                const lat = countryData.lat;\r\n                const long = countryData.long;\r\n                const population = countryData.yearPopulation;\r\n                const radius = countryData.yearRadius;\r\n                \r\n                const marker = L.circleMarker([lat, long], {\r\n                    radius,\r\n                    color: \"#007bff\",\r\n                    fillColor: \"#007bff\",\r\n                    fillOpacity: opacity\r\n                  }).bindPopup(`${country}<br>Population: ${population.toLocaleString()}`);\r\n                  \r\n                  marker.addTo(mapRef.current);\r\n                  markersRef.current.push(marker);\r\n            });\r\n          };\r\n      \r\n          updateMarkers(); // 年が変更されるたびにマーカーを更新\r\n        }, [year]); // yearが変わるたびに再描画\r\n      \r\n        return (\r\n          <div>\r\n            <div id=\"map\" style={{ height: \"90vh\" }} />\r\n                  <Typography variant=\"h6\" align=\"center\">\r\n              {year}\r\n            </Typography>\r\n            <Slider\r\n              value={year}\r\n              min={2000}\r\n              max={2020}\r\n              step={1}\r\n              onChange={(event, newValue) => SetYear(newValue)}\r\n              aria-labelledby=\"year-slider\"\r\n              valueLabelDisplay=\"auto\"\r\n            />\r\n          </div>\r\n        );\r\n    }\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}